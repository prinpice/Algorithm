# Algorithm_week10_1(Stack1)

## Stack1

### 1. Stack 자료구조의 개념

#### 1. Stack의 특성
* 프로그램에서 중요성과 활용도가 매우 높은 자료구조

  1. 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조임
  2. 스택에 저장된 자료는 선형구조를 가짐
     * **선형구조 : 자료 간의 관계까 1대 1의 관계를 가짐**
     * 비선형구조 : 자료 간의 관계가 1대 N의 관계를 가짐(예 : 트리)

  3. 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있음
  4. 마지막에 삽입한 자료를 가장 먼저 꺼냄
  5. **후입선출**(LIFO, Last-In-First-Out)이라고 부름
     * 예) 스택에 1, 2, 3순으로 자료를 삽입한 후 꺼내면 역순으로, 즉 3, 2, 1순으로 꺼낼 수 있음

#### 2. Stack의 구현

* 자료구조
  * **자료를 선형으로 저장할 저장소가 필요함**
    * C언어에서는 배열을 사용할 수 있음
    * 파있너에서는 리스트를 사용할 수 있음
    * 저장소 자체를 스택이라 부르기도 함
    * 스택에서 마지막 삽입된 원소의 위치를 top이라 부름
* 연산
  * **삽입**
    * 저장소에서 자료를 저장하고 보통 push라고 부름
  * **삭제**
    * 저장소에서 자료를 꺼냄
    * 꺼낸 자료는 삽입한 자료의 역순으로 꺼냄 보통 pop이라고 부름
  * **isEmpty**
    * 스택이 공백인지 아닌지를 확인하는 연산
  * **peek**
    * 스택의 top에 있는 item(원소)을 반환하는 연산

#### 3. Stack의 연산

* 스택의 삽입/삭제 연산 과정

  * 빈 스택에 원소 A, B, C를 차례로 삽입 후 한 번 삭제하는 연산 과정
  * 빈 스택에서 top은 가상공간(-1)을 가리키고 있음
  * 공간보다 많이 쌓으면 스택오버플로우(stackoverflow)가 발생함

* push 알고리즘

  ```python
  def push(item):
      s.append(item)
  ```

* pop 알고리즘

  ```python
  def pop():
      if len(s) == 0:
          #underflow
          return
      else:
          return s.pop(-1)
  ```

* 구현하기

  1. 스택을 구현하기

  2. 구현한 스택을 이용하여 3개의 데이터를 스택에 저장하고 다시 3번 꺼내서 출력하기

     ```python
     def push(item):
         s.append(item)
         
     def pop():
         if len(s) == 0:
             print("Stack is Empty!!")#underflow
             return
         else:
             return s.pop(-1)
         
     s = []
     push(1)
     push(2)
     push(3)
     print("pop item =>", pop())
     print("pop item =>", pop())
     print("pop item =>", pop())
     ```

* 스택 구현 고려사항

  * **리스트를 사용**하여 스택을 구현하는 경우
    * 장점: 구현이 용이함
    * **단점**: 리스트의 크기를 변경하는 작업은 내부적으로 큰 overhead  발생 작업으로 많은 시간이 소요
  * **해결방법**
    * 리스트의 크기가 변동되지 않도록 배열에서 크기를 미리 정해놓고 사용하는 방법
    * 동적 연결리스트를 이용하여 저장소를 동적으로 할당하여 스택을 구현하는 방법
    * 장점: 구현이 용이함
    * 단점: 리스트로 구현하는 것보다 구현이 복잡함

### 2. Stack의 응용

#### 1. 괄호검사

* 괄호의 종류

  * 대괄호 ('[', ']')
  * 중괄호 ('{', '}')
  * 소괄호 ('(', ')')

* 조건

  1. 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 함
  2. 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 함
  3. 괄호 사이에는 포함 관계만 존재함

* 잘못된 괄호 사용의 예

  * `(a(b)`
  * `a(b)c)`
  * `a{b(c[d]e}f)`

* 스택을 이용한 괄호 검사

* 괄호를 조사하는 알고리즘 개요

  ```mermaid
  graph TD
  A[문자열에 있는 괄호를 차례대로 조사] -->B[왼쪽 괄호를 만나면 스택에 삽입]
  A[문자열에 있는 괄호를 차례대로 조사] -->C[오른쪽 괄호를 만나면 스택에서 top 괄호를 삭제한 후 오른쪽 괄호와 짝이 맞는지 확인]
  C-->D[스택이 비어있음]
  D-->G[조건1 또는 조건 2에 위배]
  C-->E[괄호의 짝이 맞지 않음]
  E-->H[조건 3에 위배]
  C-->F[문자열 끝까지 조사한 후에도 스택에 괄호가 남아있음]
  F-->I[조건 1에 위배]
  ```

#### 2. Function call

* 함수 호출 관리

  * 프로그램에서의 **함수 호출**과 복귀에 따른 **수행 순서를 관리**

  1. 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 **후입선출 구조**이므로, 후입선출 구조의 스택을 이용하여 수행순서 관리
  2. 함수 호출이 발생하면 호출한 함수 수행에 필요한 **지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장**하여 시스템 스택에 삽입
  3. 함수의 실행이 끝나면 **시스템 스택의 top 원소(쓰택 프레임)를 삭제(pop)**하면서 프레임에 저장되어있던 **복귀주소를 확인하고 복귀**
  4. 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택이 됨

* 함수 호출 수행 순서

* 재귀 호출

  1. 자기 자신을 호출하여 순환 수행되는 것
  2. 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀 호출방식을 사용하여 함수를 만들면 **프로그램의 크기를 줄이고 간단하게 작성**할 수 있음
  3. 디버깅이 어렵고 잘못 작성하게 되면 수행 시간이 많이 소요됨

* 예) 재귀 호출을 작성할 수 있는 함수 - factorial

  * n에 대한 factorial: 1부터 n까지의 모든 자연수를 곱하여 구하는 연산

    ```python
    n! = n * (n-1)!
    (n-1)! = (n-1) * (n-2)!
    (n-2)! = (n-2) * (n-3)!
    ...
    2! = 2 * 1!
    1! = 1
    ```

  * 마지막에 구한 하위 값을 이용하여 상위 값을 구하는 작업을 반복

* 예) Factorial 함수에서 n=4인 경우의 실행

  * 스택 프레임으로 스택에 저장되는 값이 입력 값이 틀린 같은 함수의 스택 프레임을 저장한다는 차이점이 있음!

### 3. Memorization

#### 1. 피보나치 수열

* 재귀 호출을 작성할 수 있는 함수 - 피보나치 수열을 구하는 함수

  1. 0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열
     * 0, 1, 1, 2, 3, 5, 8, 13, ...
  2. 피보나치 수열의 i번 째 값을 계산하는 함수 F를 정의하면 다음과 같음
     * F~0~ = 0, F~1~ = 1
     * F~i~ = F~i-1~ + F~i-2~ for i >= 2

  3. 위의 정의로부터 피보나치 수열의 i번째 항을 반환하는 함수를 재귀 함수로 구현할 수 있음

#### 2. 피보나치 수를 구하는 재귀 함수

* 피보나치 수열을 구하는 함수의 알고리즘

  ```python
  def fibo(n):
      if n < 2:
          return n
      else:
          return fibo(n-1) + fibo(n-2)
  ```

  문제점=> **엄청난 중복 호출이 존재함**

* 피보나치 수열의 재귀 함수 Call Tree







