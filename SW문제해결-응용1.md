#  SW 문제해결 - 응용1

##  Start 

- 교재 3 ~ 52 p

###  1. SW 문제 해결

####  문제해결과정 

1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다. 
3. 어떻게 해결할 지 계획을 세운다
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다. 

####  체계적인 접근을 위한 질문들

- 비슷한 문제를 풀어본 적이 있었나?
- 단순한 방법에서 시잘할 수 있을까?
- 문제를 단순화 할 수 있을까?
- 그림을 그려볼 수 있을까? 
- 문제를 분해할 수 있을까?
- 뒤에서부터 생각해서 문제를 풀어볼 수 있을까?
- 특정 형태의 답만을 고려할 수 있을까?



###  2. 복잡도 분석

####  자주 사용하는 O - 표기 

- O(1) : 해쉬 

- O(log n) : 이진검색 , 반씩 나눠지니까 

- O(n) : 순차검색

- O(nlog n ) : 퀵 정렬, 병합정렬, 힙 정렬 

- O(n^2) : bubble 정렬, insercion 정렬, selection 정렬, 다이스트라(한 정점에서 다른 정점까지 최단거리 구하기)

- O(n^3) : 플로이드 - 워셜 (DP, 그래프) (모든 정점n에서 다른 정점까지 최단거리 구하기)

- O(2^n) : 부분집합 
- O(n!) : 순열 (TSP)

####  효율적인 알고리즘이 필요한 이유 

- 10억개 숫자를 정렬할때 : O(n^2)알고리즘 => 300년,   O(nlog n) ==> 5분 걸림

- 아무리 슈퍼컴을 써도 PC에서 효율적인 알고리즘을 쓰는 것이 훨씬 효율적이다 

  => 값비싼 하드웨어 개발 보다 효율적인 알고리즘 개발이 경제적이다. 



###  3. 표준 입출력 방법

``` python
import sys
sys.stdin = open('input.txt','r')

T = int(input())
r,c = list(map(int, input().split()))

field = []
for i in range(r+1):
    row = input()
    field.append(row)

print(T)
print(str(r)+' '+str(c))
for i in range(r+1):
    print(field[i])

# 2차배열 보기좋게 출력하기
arr = [[0,0,0,0,0],[1,1,1,1,1],[2,2,2,2,2]]
print( a for a in range(arr))
```



###   4. 비트 연산

| 연산자 | 연산자 기능                              |
| ------ | ---------------------------------------- |
| &      | 비트단위로 AND 연산                      |
| \|     | 비트단위로 OR 연산                       |
| ^      | 비트단위로 XOR 연산 (같으면 0 다르면 1)  |
| ~      | 피연산자의 모든 비트를 반전시킴          |
| <<     | 피연산자의 비트 열을 왼쪽으로 이동시킴   |
| >>     | 피연산자의 비트 열을 오른쪽으로 이동시킴 |

- 1<<n 
  - 2^n 의 값을 갖는다. 
  - 원소가 n개일 경우 모든 부분집합의 수를 의미 
  - Power set = 모든 부분집합 
    - 공집합과 자기자신을 포함한 모든 부분집합
    - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산한 것 
- i &(1<<j)
  - 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미. 

####  비트연산예제 1 

```  python 
def Bbit_print(i):
    output = ''
    for j in range(7,-1,-1):
        if i & (1<<j):
        	output += '1'
        else:
            output += '0'
    return output

for i in range(-5,6):
    print("%3d = " % i, end='')
    print(Bbit_print(i))
```

``` shell
 -5 = 11111011
 -4 = 11111100 #.. 
 -3 = 11111101 #(3의 3의보수)
 -2 = 11111110 #(0-2)(2의 2의보수)
 -1 = 11111111 #(0-1)(1의 2의보수)
  0 = 00000000
  1 = 00000001
  2 = 00000010
  3 = 00000011
  4 = 00000100
  5 = 00000101
```

**연습문제**  

> 0과 1로 이루어진 1차 배열에서 7개 byte를 묶어서 10진수로 출력하기 
>
> 예) 입력: 00000010001101 출력: -1,13을 출력한다.
>
> 입력 예 ) 
>
> 0000000111 1000000110 0000011110 0110000110 0001111001 1110011111 1001100111 
>
> (편의상 10개 단위로 간격을 둠. 이어있는 데이터로 간주하여 해결한다. )

``` python 
def bittonum(bitnum):
    #1111000
    res = 0
    for i in range(7): # 0123456
        if bitnum[i] == '1':
            res += (1<<(6-i))
    return res

inli = '0000000111100000011000000111100110000110000111100111100111111001100111'
for a in range(0,len(inli),7):
    bitnum = inli[a:a+7]
    print(bittonum(bitnum))
```



####  엔디안 (Endianness)

- 컴퓨터의 메모리와 같은 1차원 공간에 여러개의 연속된 대상을 배열하는 방법

- 주의: 속도 향상을 위해 바이트단위 와 워드단위를 변환하여 연산할 때 바르게 이해하지 않으면 오류 발생 가능

  #####  빅앤디안

  - 큰 단위가 앞에 나옴. 네트워크

  #####  리틀앤디안

  - 작은 단위가 앞에 나옴, 대다수 데스크탑 컴퓨터

  | 종류        | 0x1234 표현 | 0x12345678 표현 |
  | ----------- | ----------- | --------------- |
  | 빅 엔디안   | 1234        | 12345678        |
  | 리틀 엔디안 | 4321        | 87654321        |

  둘의 차이는 붕어를 머리부터 먹냐 꼬리부터 먹냐의 차이 

  특히 파이썬, 알고리즘 Pro 수준 이하에서는 고려대상이 아님  

####  비트연산예제 5 

- 비트 연산자 ^를 두번 하면 처음 값을 반환한다. 



###  5. 진수

- 10진수 -> 타진수로 변환 

  원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다 

- 타진수 -> 10진수로 변환 

  135<8> = `1*8^2` + `3*8^1` + `5*8^0` = 93<10>

  (135.12)<8> = `1*8^2` +  `3*8^1` + `5*8^0` +  `1*8^-1` +  `2*8^-2`   = 93.15625<10>

- ``` mermaid
  graph LR 
  2진법 -- 3자리씩 묶음 --> 8진법
  8진법 -- 3자리씩 나열 --> 2진법
  2진법 -- 4자리씩 묶음 --> 16진법
  16진법 -- 4자리씩 나열 --> 2진법
  
  ```



####  음의 정수 표현 

- 1의 보수 : 0은 1로, 1은 0으로 변환
- 2의 보수 : 1의 보수 +1 

####  연습문제 2 

> 16진수 문자로 이루어진 1차 배열이 주어질 때 앞에서부터 7bit씩 묶어 십진수로 변환하여 출력하라 
>
> ex) 0F97A3 
>
> -> 0000 1111 1001 0111 1010 0011 
>
> -> 0000111 1100101 1110100 011 
>
> -> 7, 101, 116, 3 출력 
>
> -입력 예) 01D06079861D79F99F 

``` python 
in1 = '01D06079861D79F99F'
in2 = ''
for i in range(len(in1)):
    output = ''
    # print(int(in1[i],16))
    for j in range(3,-1,-1):
        if int(in1[i],16) & 1<<j:
            output += '1'
        else:
            output += '0'
    in2 += output
# print(in2)

for a in range(0,len(in2),7):
    in3 = in2[a:a+7]
    res = 0
    # print(in3)
    for i in range(len(in3)):
        if in3[i] == '1':
            res += (1<<(len(in3)-1-i))
    print(res)
```



###  6. 실수

####  실수의 표현 1

- 컴퓨터는 실수를 표현하기 위해 부동소수점(floating-point) 표기법을 사용

- 표기방법: 소수점 위치를 고정시켜 표현 

  = 소수점 위치를 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현

  1001.0011 (진수) => 1.0010011 (가수) * 2^3(가중치)

####  실수를 저장하기 위한 형식

단정도 실수 : 부호 1비트 + 지수 8비트 + 가수 23비트 

배정도 실수 : 부호1비트 + 지수 11비트 + 가수 52비트 

- 가수부 : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한것
- 지수부 : 실제 소수점의 위치를 지수 승으로 표현한 것 

####  단정도 실수

- 단정도 실수의 가수 부분 만들기 

> 예: 1001.0011
>
> 정수부의 첫번째 자리가 1이 되도록 오른쪽으로 시프트 1.0010011
>
> 소수점이하를 23비트로 만듦 1.00100110000000000000000
>
> 소수점 이하만들 가수 부분에 저장 00100110000000000000000
>
> 지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소 +3
>
> -> 1.0010011 * 2^3

- 단정도 실수의 지수 부분 만들기 

> 지수부에는 8비트 배정 (256개의 상태를 나타낼 수 있음)
>
> 숫자로는 0-255 까지 나타낼 수 있지만 
>
> 음수값을 나타낼 수 있어야 하므로 익세스(excess) 표현법을 사용

- 단정도 실수의 지수부 익세스 표현

  - excess 표현법 : 지수부의 값을 반으로 나누어 음수지수,0,양수지수표현 

  - 

    | 실제지수 | 2진수    | 10진수값 |
    | -------- | -------- | -------- |
    | 128      | 11111111 | 255      |
    | 127      | 11111110 | 254      |
    | ...      | ...      | ...      |
    | 3        | 10000010 | 130      |
    | 2        | 10000001 | 129      |
    | 1        | 10000000 | 128      |
    | 0        | 01111111 | 127      |
    | -1       | 01111110 | 126      |
    | ...      | ...      | ...      |
    | -126     | 00000001 | 1        |
    | -127     | 00000000 | 0        |

  - 예 ) 1001.0011을 단정도 실수로 표현한 예 

    0 100000010 00100110000000000000000

####  실수의 표현 2

- 컴퓨터는 실수를 근사적으로 표현한다.
  - 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사값으로 저장되는데, 이 때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다.
- 실수 자료형의 유효 자릿수를 알아두자
  - 32비트 실수형 유효자릿수(10진수)  = 6
  - 64비트 실수형 유효자릿수(10진수) = 15
- 파이썬에서의 실수 표현 범위를 알아보자
  - 파이썬에서는 내부적으로 더 많은 비트를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있다. 
  - 최대로 표현할 수 있는 값은 약 1.8 * 10^308 이고, 이 이상은 inf로 표현
  - 최소로 표현할 수 있는 값은 약 5.0 * 10^-325이며, 이 이하는 0으로 표현 

####  연습문제 3 

> 16진수 문자로 이루어진 1차 배열이 주어질 때, 암호비트패턴을 찾아 차례대로 출력하시오. 암호는 연속되어 있다. 
>
> | -    | 암호비트패턴 |
> | ---- | ------------ |
> | 0    | 001101       |
> | 1    | 010011       |
> | 2    | 111011       |
> | 3    | 110001       |
> | 4    | 100011       |
> | 5    | 110111       |
> | 6    | 001011       |
> | 7    | 111101       |
> | 8    | 011001       |
> | 9    | 101111       |
>
> 예) 0DEC(16) 일 경우 
>
> -> 0000 1101 1110 1100(2)
>
> -> 00 001101 111011 00 
>
> -> 0, 2 가 출력된다. 
>
> 입력 예 > 0269FAC9A0 

``` python
inli0 = '0DEC'
inli1 = '0269FAC9A0'

def f16t2(li):
    res = ''
    for i in range(len(li)):
        oooo = ''
        for j in range(3,-1,-1):
            if int(li[i],16) & (1<<j):
                oooo += '1'
            else:
                oooo += '0'
        res += oooo
    return res

def solve(li):
    pat = {'001101':0,'010011':1,'111011':2,'110001':3,'100011':4,
           '110111':5,'001011':6,'111101':7,'011001':8,'101111':9}
    for i in range(len(li)-1,-1,-1):
        if li[i] == '1':
            li = li[:i+1]
            break
    li = li[len(li)%6:]

    for a in range(0,len(li),6):
        print (pat[li[a:a+6]], end=' ')
    print()

solve(f16t2(inli0))
solve(f16t2(inli1))
```

