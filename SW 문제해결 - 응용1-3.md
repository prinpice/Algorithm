# SW 문제해결 - 응용1-3

## 분할정복 & 백트래킹

- 교재 125  p ~ 
- 학습목표
  - 문제를 분할해서 해결하는 분할정복 기법 이해 
  - 대표적인 알고리즘인 퀵 정렬, 병합정렬 학습
  - 상태공간 트리의 모든 노드를 검색하는 백트래킹 학습
  - 이진 트리의 특성 이해, 이진 트리의 중요 연산인 탐색, 삽입, 삭제 알고리즘 학습

### 1. 분할정복

- 문제 : 가짜 동전 찾기

####  개념 

- 유래
- 설계전략 

####  기법

- Top-down approach
- 거듭제곱 : 반복 알고리즘 O(n)
- 분할정복 기반의 알고리즘 O(log₂n)

####  1-1. 병합정렬

- 개념 : 여러 정렬된 자료의 집합을 병합하여 한개의 정렬된 집합으로 만드는 방식

- 활용 : 자료를 최소단위의 문제까지 나눈 후 차례대로 정렬하여 결과 도출 (Top-down)

- 시간복잡도 O(n log n)

- 과정 

  > {69, 10, 30, 2, 16, 8, 31, 22} 병합정렬 
  >
  > 1. 분할 
  >
  > 전체 자료 집합에 대해 최소크기의 부분집합이 될 때까지 분할작업 계속 
  >
  > {69, 10, 30, 2} {16, 8, 31, 22}
  >
  > {69, 10} {30, 2} {16, 8} {31, 22}
  >
  > {69}{10} {30}{2} {16}{8} {31}{22}
  >
  > 2. 병합
  >
  > 2개 부분집합을 정렬하면서 하나의 집합으로 병합
  >
  > n개의 부분집합이 1개로 병합될 때 까지 반복
  >
  > {69}{10} {30}{2} {16}{8} {31}{22}
  >
  > {10, 69} {2, 30} {8, 16} {22,31}
  >
  > {2, 10, 30, 69} { 8,16 ,22,31}
  >
  > {2,8,10,16,22,30,31,69}

####  1-2. 퀵 정렬

- 개념 : 주어진 배열을 두 개로 분할 후 각각을 정렬

- 병합정렬과 비교 :

  1. 병합정렬은 단순 둘로 나눔, 퀵정렬은 분할시 기준 아이템 중심으로 기준보다 작으면 왼편, 크면 오른편에 위치
  2. 각 부분 정렬이 끝난 후 병합정렬은 '병합'을 하는 후작업이 필요, 퀵정렬은 필요 없음 

- 코드 

  ``` python
  def Quicksort(A,l,r):
      if l < r :
          s = partition(A,l,r)
          Quicksort(A,l,s-1)
          Quicksort(A,s+1,r)
          
  def partition(A,p,r):
      x = A[r]
      i = p-1
      for j in range(p,r-1):
          if A[j] <= x:
              i += 1
              A[i], A[j] = A[j], A[i]
      A[i+1], A[r] = A[r], A[i+1]
      return i + 1
  
  A = [1,2,3,6,9,4,8,7,5]
  Quicksort(A,0,8)
   
  ```

- 문제 : 병뚜껑 속의 숫자 게임

####  1-3. 이진 검색

- 개념 : 

- 주의 : 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다. 

- 과정 

  1. 자료 중강 원소를 고른다 

  2. 중앙 원소의 값과 찾고자 하는 목표값을 비교

  3. 목표값이 중앙 원소 값보다 작으면 자료 왼쪽 반에 대해 새로검색

     or 크다면 자료 오른쪽 반에 대해 새로 검색 

  4. 목표값을 찾을 때까지 1.~3. 반복

####  분할정복 활용

- 병합정렬은 외부 정렬의 기본이 되는 정렬 알고리즘이다. 

  또한 멀티코어CPU나 다수 프로세서에서 정렬 알고리즘을 병렬화 하기 위해 병합 정렬 알고리즘이 활용된다. 

- 퀵 정렬은 매우 큰 입력 데이터에 대해 좋은 성능을 보이는 알고리즘이다. 

- 최근접 점의 쌍 (: Closet Pair) 문제는 2차원 평면상의 n 개의 점이 입력으로 주어질 때, 거리가 가장 가까운 한 쌍의 점을 찾는 문제이다. 

####  연습문제 

- 연습문제 1 : 퀵정렬 

  > 배열의 데이터를 퀵정렬 하는 함수를 작성하시오
  >
  > 입력 예 
  >
  > ``` python
  > 11 45 23 81 28 34
  > 11 4 22 81 23 34 99 22 17 8
  > 1 1 1 1 1 0 0 0 0 0
  > ```

- 연습문제 2 : K번째 숫자 

  >K번째 숫자 
  >
  >수 N개 가 주어진다. A₁,A₂,A₃, ...An 를 오름차순 정렬 했을 떄, 앞에서부터 K번째 있는 수를 구하는 프로그램을 작성하시오
  >
  >입력 
  >
  >- 첫째 줄에는 N(1<= N <= 5,000,000) 과 K(1 <= K <= N)가 주어진다. 
  >
  >- 둘째 줄 에는 A₁,A₂,A₃, ...An이 주어진다. (-10^9 <= Ai <= 10^9)
  >
  >  ```
  >  8 7
  >  5 1 2 8 3 0 -1 -4
  >  ```
  >
  >출력 
  >
  >- A를 정렬 했을 때, 앞에서부터 K번쨰 있는 수를 출력한다. 
  >
  >  ``` 
  >  5
  >  ```



### 2. 백트래킹

- 문제 : N-Queen 문제 ( 예: 퀸 8개 )
  - 후보 해의 수 :  64C8 = 64! / 8!(64-8)! = 4,425,165,368
  - 실제 해의 수 : 단 92개 
  - 결론 : 44억개가 넘는 후보 해들 중 92개를 최대 효율로 찾아내는 것이 관건

####  개념

- 여러 옵션(선택지)가 존재하는 상황에서 한가지를 선택

- 선택 후엔 새로운 선택지들의 집합이 생성 됨

- 선택을 반복하면서 최종상태에 도달 

  : 올바른 선택을 계속하면 목표상태에 도달 

- 당첨 리프 노드 찾기 

  - 루드에서 살 수 있는 노드 선택
  - 꽝 노드에 도달하면 최근 선택으로 돌아와 다시 시작
  - 더이상 선택지가 없다면 이전 선택지로 돌아가 다른 선택 
  - 루트까지 돌아갔을 경우 더이상 선택지가 없다면? 찾는 답이 없는 것

####  DFS와 비교

- 가지치기 가능 : 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더이상 그 경로를 따라가지 않음 
- 불필요한 경로를 조기에 차단 
- N! 가지 경우 수를 가진 문제에 대해 DFS로 처리하기엔 불가능한 문제 해결 
- 다만 최악의 경우 여전히 지수함수 시간을 요하므로 처리 불가능할 수 있음

####  절차

1. 상태공간 트리의 깊이우선 검색 실시
2. 각 노드가 유망한지 점검
3. 유망하지 않다면 그 노드의 부모노드로 돌아가서 검색 계속 



### 3. 트리

