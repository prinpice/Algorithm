# SW 문제해결 - 응용1-2

## 완전 검색 & 그리디 

- 교재 53 ~ 124  p

###  1. 반복과 재귀

####  1-1. 학습목표

####  1-2. 반복과 재귀

- 반복구조

- 반복을 이용한 선택정렬

- 재귀적 알고리즘

- 재귀함수
- 팩토리얼 재귀함수
- 반복 or 재귀? 
- 연습문제 : 선택 정렬 함수를 재귀적 알고리즘으로 작성해 보자

### 2. 완전 검색 기법

####  2-1. Baby-gin Game

- 설명
  - 0~ 9 숫자 타드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run, 3장의 카드가 동일한 번호를 갖는 경우 triplet
  - 6장의 카드가 run과 triplet으로만 구성된 경우 baby-gin
- 연습문제
  - 6자리의 숫자를 입력받아 baby-gin여부를 판단하는 프로그램 작성
  - 입력 : 결과 예
    - 667767 : True
    - 054060 : True
    - 101123 : False

####  2-2. Brute-force

- Brute-force

- Brute-force 탐색

- 완전검색으로 시작하라

- 완전검색을 통한 baby-gin 접근

- 완전검색은 다시 


### 3. 조합적 문제

- 문제제시 : 여행사 BIG Sale 

####  3-1. 순열 

- 개념

- 10<= N <= 20

- 순열 생성방법

  - 단순 생성

  - 사전적 순서

  - 최소 변경을 통한 방법

  - 재귀 호출을 통한 순열 생성 

    - 아래 생성 코드1,2는 문제풀이때 보통 사용되지 않는다. 

      다만 아래를 통해 어떻게 돌아가는지 개념적으로 이해를 먼저 하고

      3번 코드를 활용하여 문제풀이를 하도록 하자. 

    1. 

    ``` python
    # arr [] : 데이터가 저장된 배열 
    # swap(i,j) : arr[i] 와 arr[j]를 교환
    # n : 원소개수 
    # k : 현재까지 교환된 원소 개수
    perm(n,k):
        if k == n:
            print(array)
        else:
            for i in range(n-1,-1,-1):
                swap(a[i],a[n-1])
                t[r-1] = a[n-1]
                perm(a[n-1],r-1)
                swap(a[i],a[n-1]) # 제일 뒤에있는 값을 원래자리 i에 놓아라
    ```

    2.  

    ``` python
    perm(k):
        if k == R:
            print(array)
        else:
            for i in range(k,N-1):
                swap(k,i)
                perm(K+1)
                swap(k,i) 
    ```

    ``` mermaid
    graph TD
    k=0 --1--> B; k=0 --1--> C; k=0 --1--> D;
    B --2--> 1,2; B -- 2--> 1,3; 1,2--> B; 1,3-->B; 
    C --2--> 2,1; C -- 2--> 2,3; 2,1--> C; 2,3-->C; 
    D --2--> 3,2; D -- 2--> 3,1; 3,2--> D; 3,1-->D; 
    
    ```

    3. 

    ``` python
    Visited[N-1]
    perm(k):
        if k == r :
            print(arr)
        else:
            for i in range(0,N):
                if visited[i] :
                    continue
                t[k] = a[i]
                visited[i] = True
                perm(k+1)
                visited[i] = False
    ```

    ``` mermaid
    graph TD
    A --0--> i=0;
    i=0 --1--> i=1; 
    i=0 --1--> B; B --2--> 2,1; B --2--> 2,3; 
    i=1 --2--> 1,2; i=1 --2--> 1,3; 1,2 --> i=1; 1,3 --> i=1; 
    i=1 --> i=0; 
    2,1-->B; 2,3-->B; B-->i=0; 
    i=0 --1--> C; C --2--> 3,1; C --2--> 3,2;
    3,1 --> C; 3,2-->C; C-->i=0;
    i=0 --> A;
    ```

#### 3-2. 부분집합

- 개념

  - 집합에 포함된 원소들을 선택하는 것

  - 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분집합을 찾는것

    ​	ex) 배낭 짐싸기

  - N개의 원소를 포함한 집합 

    - 자기 자신 , 공집합을 포함한 모든 부분집합 수 : 2ⁿ개 
    - 원소의 수가 증가하면 부분집합의 개수는 지수적으로 증가 

- 부분집합 생성방법

  - 단순 : 원소를 포함한 집합에 대한 power set구하기

    ``` python
    for i1 in (2): # 0,1
        bit[0] = i1
        for i2 in (2):
            bit[1] = i2
            for i3 in (2):
                bit[2] = i3
                for i4 in (2):
            		bit[3] = i4
                    print(array)
    ```

  - 바이너리 카운팅으로 사전적 순서 생성

    - 부분집합을 생성하기 위한 가장 자연스러운 방법
    - 바이너리 카운팅은 사전적 순서로 생성하기 위한 간단한 방법

    - N개 (= 원소 수)의 비트열을 이용

    - n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미 

      | 10진수 | 2진수 | {A,B,C,D} |
      | ------ | ----- | --------- |
      | 0      | 0000  | {}        |
      | 1      | 0001  | {A}       |
      | 2      | 0010  | {B}       |
      | 3      | 0011  | {B,A}     |
      | ...    | ...   | ...       |
      | 13     | 1101  | {D,C,A}   |
      | 14     | 1110  | {D,C,B}   |
      | 15     | 1111  | {D,C,B,A} |

    - ``` python
      # 바이너리 카운팅을 통한 부분집합 생성 코드 
      
      # 어떤 순서로 하는지 파악하기는 쉽지않다. 
      # -> 0:[4] , 1: [5], 2:[4,5], 3:[1], 3:[1,4] .. 
      # 이런식으로 진행되므로. 
      
      # 그래서 중간과정에서 뭔가 제어하기는 어렵다. 
      # 상당히 효율적이기는 하다.
      
      arr = [3,6,7,1,5,4]
      n = len(arr)
      for i in range(0, (1<<n)):
          # 1<<n : 부분집합의 개수
          	for j in range(0,n): # 원소 수만큰 비트 비교
                  if i & (1<<j): 
                      print('%,' % arr[j], end='')
                      # i의 j번째 비트가 1이면 j번째 원소 출력
          print()
      ```


#### 3-3. 조합

- 개념

  - 서로 다른 n개의 원소중 r개를 순서 없이 골라낸 것을 조합이라고 부른다.

  - 'powerset을 구하는 백트래킹 알고리즘'과 함께 학습하기 (교재 173p)

  - 조합 수식

    ``` 
    nCr = n! / (n-r)!r!
    nCr = n-1Cr-1 + n-qCr  (재귀적 표현)
    nC0 = 1 
    ```

- 조합 생성 알고리즘 : 재귀 호출 

  ``` python
  an = [] #n개의 원소를 가지고 있는 배열 [1,2,3]
  tr = [] #r개의 크기의 배열 , 조합이 임시 저장될 배열 []
  def comb(n,r):
      if r == 0 :
          print(tr)
      elif n<r :
          return
      else:
          tr[r-1] = an[n-1]
          comb(n-1, r-1)
          comb(n-1, r)
  ```

  ``` mermaid
  graph TD
  A--m=3,r=2--> B; B--2,1-->C; C--1,0-->2,3;
  2,3-->C; C--1,1-->D; D--0,0-->1,3; 1,3-->D; 
  D-->C; C-->B;
  B--2,2-->E; E--1,1-->F; F--0,0-->G; G-->F;
  F--0,1-->H; H-->F; F-->E; E--1,2-->I; 
  I-->E; E-->B; B-->A; 
  ```

  - 위에서 F, G, H 부분은 (0,0) (0,1) (1,1) 이 중복이므로 패스한다. 

- 중복조합 생성 재귀적 알고리즘

  중복조합의 예 : 1, 2, 4, 6, 8원 짜리 동전으로 8원 만들기 (순서없는 중복조합) 

  ``` python
  # 선생님이 짜놓은 6가지 중복조함 생성 알고리즘 열람하기
  
  # Depth로 관리하기
  # 초기값 
  K = 0, s = 1, N, R
  def Hr2(k,s): # 깊이, 시작숫자
      if k == R:
          print(t[0],t[1])
      else:
          for i in range(s,N):
              t[k] = a[i]
              Hr2(k+1,i)
              
  def pi_i(): 
      for i in range(N):
          for j in range(N):
              print(a[i],a[j])
  def H_i():
      for i in range(N):
  
  def comb_r_1(n,r):
  
  def pi_r_2()    
      
  ```

- 연습문제 : 부분집합의 합 구하기

  > 아래의 10개의 정수 집합에 대한 모든 부분집합 중 원소의 합이 0이 되는 부분집합을 모두 출력하시오 
  >
  > ex) {-1,3,-9,6,7,-6,1,5,4,-2}

- 문제 : 프로젝트 배분

  >프로젝트와 회사가 N개 있다. 각 회사는 각 프로젝트의 입찰가를 제출한다. 프로젝트를 한 회사에 하나씩 골고루 나누어 주고 싶다. 총합이 최소가 되도록 나누어 주고 싶다. 최소 총합은 얼마가 되는가? 
  >
  >N< 11
  >
  >``` input
  >1
  >7
  >88 51 24 88 94 50 60
  >1 55 1 23 12 84 90
  >26 44 81 97 33 82 30
  >3 71 12 99 6 92 48
  >87 5 14 93 28 92 56
  >15 25 92 64 52 67 51
  >...
  >```
  >
  >- 그리디로 하면 안된다.
  >- 순열문제이다. 

- 문제: 병원짓기

  > - N개의 마을이 있고 마을에 병원을 짓는 비용이 주어진다.
  > - 도로로 직접 연결된 이웃 마을에서 병원 진료를 받을 수 있다. 
  > - 도로로 연결된 이웃 마을의 관계가 주어진다. 
  > - 모든 마을의 사람들이 병원진료를 받을 수 있도록 최소 비용으로 병원을 짓고자 할때 최소 비용이 얼마인가?
  > - 당연히 자기 마을에 병원이 있으면 자기 마을에서 병원 진료를 받을 수 있다. 
  >
  > in[]: 
  >
  > ```input
  > 1  //테스트케이스 개수
  > 5
  > 100 70 50 80 10 
  > 0 1 0 1 0
  > 1 0 1 0 1
  > 0 1 0 0 0
  > 1 0 0 0 0 
  > 0 1 0 0 0
  > ```
  >
  > out[] : 140 
  >
  > - 부분집합으로 접근한다 : 1개를 선택할 수 도, 2개를 선택할 수 도 있다. 
  > - 후처리가 필요하다 : 병원을 지은 후 - 마을이 커버가 모두 되는지, 비용이 작은지 . 



### 4. 탐욕 알고리즘

- 연습문제 : 손님이 지불한 금액에서 물건값을 제한 차액(거스름돈)을 지불하자

  어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?

  백트래킹 너비우선탐색..? 

####  4-1. 탐욕 알고리즘

- 개념

  - 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
  - 일반적으로 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy접근
  - 여러 경우 중 하나를 선택할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
  - 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 해서 **그것이 최적이라는 보장은 없다.** 
  - 일단 한번 선택된 것은 번복하지 않는다. 그러므오 탐욕 알고리즘은 대체로 단순하며, 제한적인 문제에 적용된다.
  - 최적화 문제란 가능한 해들 중 가장 좋은 (최대, 최소) 해를 찾는 문제이다.

- 탐욕 알고리즘의 동작 과정

  1. **해 선택** : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합에 추가
  2. **실행 가능성 검사**: 새로운 부분해 집합이 실행가능한지 확인 (= 문제 제약조선을 위반하지 않는지 검사)
  3. **해 검사** : 새로운 부분 해 집합이 문제의 해가 되는지 확인. 아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작.

  - 최적해를 반드시 구한다는 보장이 없다 = **검증해야 한다**. 

- 예 ) 탐욕 기법을 적용한 거스름돈 줄이기

  1. 해 선택 : 멀리 볼 것 없이 가장 좋은 해 선택. 현재 고를 수 있는 단위가 가장 큰 동전을 하나 골라 거스름돈에 추가한다.
  2. 실행 가능성 검사 : 거스름돈이 손님에게 줘야 할 핵수를 초과하는지 확인. 초과한다면 마지막에 추가한 동전을 거스름돈에서 뺴고, 해 선택으로 돌아가 한 단계 작은 단위의 동전 추가
  3. 해 검사 :  거스름돈을 확인해서 액수에 모자르면 다시 해 선택으로 돌아가 거스름돈에 추가 할 동전을 고른다. 

  - 최적해를 반드시 구한다는 보장이 없다 

    > 물건값 1200원 , 받은 돈 2000원 , 거스름돈 800원
    >
    > | Case 1                | Case2                                                 |
    > | --------------------- | ----------------------------------------------------- |
    > | 500 ,100 , 50, 10     | 500, 400, 100, 50, 10                                 |
    > | 500원 1개 , 100원 3개 | Greedy : 500원 1개 , 100원 3개<br />최적해: 400원 2개 |

     

#### 4-2. Knapsack 문제유형

> 도둑은 값진 물건들을 훔피기 위해 침입했다. 배낭에 담을 수 있는 물건의 총 무게는 W이다.
>
> 창고에는 여러개 (n개)의 물건들이 있고, 각각 물건에는 무게, 값이 정해져 있다.
>
> 배낭이 수용할 수 있는 무게를 초과하지 않으면서 값이 최대가 되는 물건들을 담아야 한다. 
>
> 배낭 수용 무게 : 30 kg 
>
> | 물건 | 무게 (kg) | 값 (천만원) |
> | ---- | --------- | ----------- |
> | A    | 25        | 10          |
> | B    | 10        | 9           |
> | C    | 10        | 5           |
> | ...  | ...       | ...         |

- Knapsack 문제의 정형적 정의 

  - S = {Item₁,Item₂,...Itemｉ} 물건들의 집합

  - wｉ = Itemｉ 의 무게,  Pｉ =Itemｉ 의 값

  - W : 배낭이 수용 가능한 총 무게 

  - 문제정의 

    : ∑itemｉ∈A  wｉ ≤ W 를 만족하면서 ∑itemｉ∈A  Pｉ 가 최대가 되도록 A ⊆ S가 되는 A를 결정하는 문제 

- Knapsack 문제 유형

  - **0-1knapsack** : 배낭에 물건을 통쨰로 담아야 하는문제, 물건을 쪼갤 수 없는 경우
  - **Fractional Knapsack** : 물건을 부분적으로 담는것이 허용되는 문제, 물건을 쪼갤 수 있는 경우

#####  (1) 0-1 Knapsack

- 0-1 Knapsack에 대한 완전 검색 방법 
  - 완전 검색으로 물건들의 집합 S에 대한 모든 부분집합을 구한다.
  - 부분집합의 총 무게가 W를 초과하는 집합들은 버리고, 나머지 집합에서 총 값이 가장 큰 집합을 선택할 수 있다.
  - 물건 개수가 증가하면 시간 복잡도가 지수적으로 증가한다 : 크기 n인 부분집합의 수 2ⁿ

1. 0-1 Knapsack에 대한 탐욕적 방법 1 

   - W = 30kg

     | -     | 무게 | 값   |
     | ----- | ---- | ---- |
     | Item₁ | 25   | 10   |
     | Item₂ | 10   | 9    |
     | Item₃ | 10   | 5    |
     - 값이 비싼 물건부터 채운다. 

     - 그리디 : 물건1 , 25kg, 10만원

       최적해 : 물건2, 물건3 , 20kg, 14만원

       -> 최적이 아니다. 

2. 0-1 Knapsack에 대한 탐욕적 방법 2

   - W = 30kg

     | -     | 무게 | 값   |
     | ----- | ---- | ---- |
     | Item₁ | 25   | 15   |
     | Item₂ | 10   | 9    |
     | Item₃ | 10   | 5    |

     - 무게가 가벼운 물건부터 채운다. 

     - 그리디 : 물건2+3, 14만원

       최적해 : 물건1, 15만원

       -> 역시 최적이 아니다. 

3. 0-1 Knapsack에 대한 탐욕적 방법 3

   - W = 30kg

     | -     | 무게 | 값   | 값/kg |
     | ----- | ---- | ---- | ----- |
     | Item₁ | 5    | 50   | 10    |
     | Item₂ | 10   | 60   | 6     |
     | Item₃ | 20   | 140  | 7     |

     - 무게 당 값이 높은 순서로 채운다. 

     - 그리디 : 물건1+3, 190만원

       최적해 : 물건2+3, 200만원

       -> 역시 최적이 아니다. 

- 그리디 알고리즘으로는 최적해를 구하기 어렵다. 
- 부분집합문제이다.

##### (2)  Fractional Knapsack 문제

- 물건의 일부를 잘라서 감을 수 있다. 

- W = 30kg

  | -     | 무게 | 값   | 값/kg |
  | :---- | ---- | ---- | ----- |
  | Item₁ | 5    | 50   | 10    |
  | Item₂ | 10   | 60   | 6     |
  | Item₃ | 20   | 140  | 7     |

  - 그리디 : 물건1+3+2의 절반, 30kg ,220만원

####  4-3. Activity-selection 문제유형

- 문제 정의 : 회의실 배정하기

  > 김대리는 회의실 사용신청을 처리하는 업무를 한다.
  >
  > 사용하등한 회의실은 1개이고, 다수의 최의가 신청된 상태이다.
  >
  > 최의는 시작시간, 종료 시간이 있으며, 시간이 겹치는 회의는 동시에 열릴 수 없다.
  >
  > 가능한 많은 회의가 열리기 위해서 회의들은 어떻게 배정되어야 할까? 
  >
  > ``` input
  > 10 //회의 개수
  > 1 4  1 6  6 10  5 7  3 8  5 9  3 5  8 11  2 13  12 14  // 시작시간, 종료시간 
  > ```

  - 시작시간 si, 종료시간 fi이 있는 n개의 활동들의 집합 A = {A₁,A₂,A₃,...An}, 1≤i≤n에서 

    서로 겹치지 않는 최대갯수의 활동들의 집합 S를 구하는 문제 

  - 양립 가능한 활동들의 크기가 최대가 되는 S(0,n+1) 의 부분집합을 선택하는 문제

    - 종료 시간 순으로 활동 정렬

    - S(0,n+1)는 a(0)의 종료 시간부터 a(n+1) 의 시작시간 사이에 포함된 활동들

    - S(0,n+1) = {a₁,a₂,a₃,a₄,.. a(10)} = S 

      | i    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 시작 |      | 1    | 3    | 1    | 5    | 3    | 5    | 6    | 8    | 2    | 12   | ∞    |
      | 종료 | 00   | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 13   | 14   |      |

- 탐욕 기법 적용

  - 공집합이 아닌 하위문제 S(i,j)가 있고, S(i,j)에 속한 활동 a(m)은 종료시간이 가장 빠른 활동이다.

  - 그렇다면:

    1. 하위문제 S(i,j)에서 종료 시간이 가장 빠른활동 a(m)을 선택한다.
    2. S(i,m)은 공집합이므로 a(m)을 선택하면 공집합이 아닌 하위문제 S(m,j)가 남는다. 
    3. 1,2과정을 반복한다.

  - S(i,j)를 풀기 위해 

    1. 종료시간이 가장 빠른 a(m)선택
    2. S(i,j) ={a(m)}∪ S(m,j)의 해집합

    - S(0,11)에 대해, a(1)을 선택하고, S(1,11)을 푼다.

    - S(1,11)에 대해, a(4)을 선택하고, S(4,11)을 푼다.

    - S(4,11)에 대해, a(8)을 선택하고, S(8,11)을 푼다.

      ​			- 탐욕적 선택 		- 탑다운 방식의 문제 해결

- 탐욕 기법을 적용한 반복 알고리즘

  ``` python 
  A = [] # 활동들의 집합
  S = [] # 선택된 활동(회의)들 집합
  si = # 시작시간 
  fi = # 종료시간 
  # 1 <= i <= n
  # Sort A by finish time 종료시간이 빠른 순서로 활동들을 정렬한다.
  S = {A[0]} # 첫번째 활동을 선택한다. 
  j = 1
  for i in range(2,n): # 선택한 활동의 종료시간보다 빠른 시간 시간을 가지는 활동을 모두 제거.
      if si >= fj:
          S = S + {Ai}
          j = i 
          # 남을 활동들에 대해 앞의 과정 반복
  ```

- 예제 : 종료시간으로 정렬된 10개의 회의들

  > a = (1,4),(3,5),(1,6),(5,7),(3,8),(5,9),(6,10),(8,11),(2,13),(12,14)

  선택된 회의 a[0] 일 때, a[1],a[2] 삭제

  다음 a[3]선택  a[4],a[5],a[6] 삭제

  다음 a[7]선택  a[8] 삭제

- 재귀 알고리즘

  ``` python
  A = [ (1,4),(3,5),(1,6),(5,7),(3,8),(5,9),(6,10),(8,11),(2,13),(12,14)] 
  S = [] 
  # si , fi =시작시간, 종료시간
  def Recursive_Selection(i,j):
      m = i+1
      while m < j and si < fi :
          m += 1
      if m < j :
          return A[m] + Recursive_Selection(i,j)
      else:
          return []  # 공집합 
  ```


####  4-4. 탐욕 알고리즘의 필수 요소

- 탐욕적 선택 속성 : 탐욕적 선택은 최적해로 갈 수 있음을 보여라 
- 최적 부분 구조 : 최적화 문제를 정형화하라 (= 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다.)
- **[원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해]**

#### 4-5. 탐욕 기법과 동적 계획법의 비교 

- 

  | 탐욕기법                                                     | 동적계획법(DP)                                               |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 매 단계에서, 가장 좋게 보이는 것을 빠르게 선택<br /> = 지역 최적 선택 | 매 단계에서 선택은 해결한 하위 문제의 해를 기반으로 함<br />= 메모 |
  | 하위 문제를 풀기 전에 탐욕적 선택이 먼저이루어짐             | 하위 문제가 우선 해결됨                                      |
  | Top-down                                                     | Bottom-up                                                    |
  | 일반적으로 빠르고 간결하다                                   | 좀더 느리고 복잡하다.                                        |

- 대표적인 탐욕 기법의 알고리즘들

####  4-6. 탐욕 기법을 통한 baby-gin 문제 해결

- 완전검색이 아닌 방법으로 풀어보자

  > 6개 숫자는 6자리 정수값으로 입력됨 
  >
  > counts 배열의 각 원소를 체크하여 run과 triplet 및 baby-gin 여부를 판단한다.
  >
  > ex) 444345

  ```
  counts[0,0,0,1,4,1,0,0,0,0] run 조사 후 run 데이터 삭제 
  counts[0,0,0,0,3,0,0,0,0,0] triplet 조사, baby-gin 
  ```

  > ex) 444456

  ``` 
  counts[0,0,0,0,4,1,1,0,0,0] triplet 조사 후 triplet 데이터 삭제 
  counts[0,0,0,0,1,1,1,0,0,0] run조사, baby-gin 
  ```


