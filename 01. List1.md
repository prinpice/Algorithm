# 01. List1

## 1. 알고리즘

### 1. 알고리즘 개요

* 알고리즘이란?

  * 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

  1. 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계쩍 방법
  2. 어떠한 문제를 해결하기 위한 절차

  * 예) 1부터 100까지의 합을 구하는 문제

  ${(1 + 100) + (2 + 99) + (3 + 98) ... (50 + 51)} * 50 = 5050$

* 알고리즘 표현법

  * 슈도 코드

    * 특정 프로그래밍 언어의 문법을 따라 쓰여진 것이 아니라, **일반적인 언어로 코드를 흉내 내어 알고리즘을 써 놓은 코드**

    ```python
    def calcSum(n):
        sum = 0
        for i in range(1, n+1):
            sum = sum + i
        return sum
    
    print(calcSum(100))
    ```

    * **의사 코드**로 흉내만 내는 코드
    * 실제적인 프로그래밍 언어로 작성된 코드처럼 **컴퓨터에서 실행할 수 없음**
    * 특정 언어로 **프로그램을 작성하기 전**에 알고리즘을 대략적으로 모델링하는 데에 쓰임

  * 순서도

    * 프로그램이나 작업의 **진행 흐름**을 순서에 따라 여러가지 기호나 문자로 나타낸 도표

    ```flow
    op1=>operation: sum <- 0
    op2=>operation: i <- 1
    cond=>condition: i <= 100
    op3=>operation: sum <- sum + i
    op4=>operation: i <- i + 1
    op5=>operation: print sum
    op1->op2->cond
    cond(yes)->op3
    cond(no)->op5
    op3->op4->cond
    ```

    * **흐름도**, 프로그램의 논리적인 흐름, 데이터의 처리 과정을 표현하는 데 사용
    * **프로그램을 작성하기 전**에 프로그램의 전체적인 흐름과 과정 파악을 위해 필수적으로 거쳐야 되는 작업

  ### 2. 알고리즘의 성능 분석

* 무엇이 좋은 알고리즘인가?

  * 정확성
    * 얼마나 정확하게 동작하는가?
  * 작업량
    * 얼마나 적은 연산으로 원하는 결과를 얻어내는가?
  * 메모리 사용량
    * 얼마나 적은 메모리를 사용하는가?
  * 단순성
    * 얼마나 단순한가?
  * 최적성
    * 더 이상 개선할 여지 없이 최적화되었는가?

* 알고리즘의 성능 분석 필요

  * 많은 문제에서 알고리즘의 성능 분석 기준으로 알고리즘의 작업량을 비교

  * 예) 1~ 100까지의 합을 구하는 문제

    * 알고리즘 1: 99번의 연산(덧셈 99번)

    $1+2+3+...+100 = 5050$

    * 알고리즘 2: 3번의 연산(덧셈 1번, 곱셈 1번, 나눗셈 1번)

    $100 * (1 + 100)/2 = 5050$

  * 더하려는 범위가 클수록 연산 횟수의 차이가 커짐

  * 실제 걸리는 시간을 측정

  * **실행되는 명령문의 개수를 계산**

  * 알고리즘1

  ```python
  def calcSum(n):
      sum = 0 # 1번
      for i in range(1, n+1): # 1번
          sum = sum + 1 # 1번
          return sum
  ```

  $1 + n * 2 = 2n + 1$

  * 알고리즘2

  ```python
  def calcSum(n):
      return n * (n + 1)// 2 # 3번
  ```

  3번의 연산

* 시간 복잡도 ~+ 빅-오(O) 표기법

  * 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
  * 계수(Coefficient)는 생략하여 표시
  * 예) 빅-오(O) 표기법

  $O(2n + 1) = O(2n) = O(n) $# 최고차 항(2n)만 선택 #계수 2제거

  $O(2n^{2} + 10n + 100) = O(n^{2})$

  $O(4) = O(1)$

  * 요소 수가 증가함에 따라 각기 다른 시간복잡도의 알고리즘은 아래와 같은 연산 수를 보임
  * 시간 복잡도별 실제 실행 시간 비교표

* 어떤 알고리즘을 선택하시겠습니까?

  1. A 알고리즘: **시간 복잡도 logN** / B 알고리즘: **시간 복잡도** $N^{2}$

  2. 대한민국 인구에 대해 정보 조회하기

     A 프로그램 : **1초** / B 프로그램 : **500일**

     => 시간 복잡도의 필요성

## 2. List

### 1. Python 소개

* 파이썬(Python)

  * 1991년 귀도 반 로섬이 개발한 프로그래밍 언어
    1. 인터프리어 언어로 독립적인 플랫폼
    2. 객체지향
    3. 파이썬2와 파이썬3 버전이 배포중, 파이썬 재단은 파이썬3을 권장
    4. IoT분야의 라지베리파이, 최근 빅데이터의 자료분석 등에서 파이썬의 관심이 높아짐
  * 프로그램 실행 속도에 관심 집중
    * 하드웨어 성능이 좋지 않던 시기에는 프로그램의 실행 속도가 크게 차이가 남
      * => 실행 속도가 느린 파이썬이 주목받지 못함
  * 개발 시간 단축에 관심 집중
    * 하드웨어의 성능 개선으로 실행 속도의 차이가 크지 않음
      * => **많은 개발자들이 파이썬을 사용함**

* 변수

  1. 파이썬에서는 모든 자료는 객체

     * Java나 C에서 사용되는 기본형 타입 변수도 파이썬에서는 객체

  2. 변수의 선언은 따로 없음

     * 변수에 값을 초기화 시 변수가 메모리에 생성
     * 하나의 변수에 다른 타입의 값을 변수에 저장할 수 있음

     ```python
     a = 3
     a = "hello"
     ```

* 자료형

  |  타입  | type()  |        |          |
  | :----: | :-----: | :----: | :------: |
  |  정수  |   int   | 리스트 |   list   |
  |  실수  |  float  |  사전  |   dict   |
  | 복소수 | complex |   셋   |   set    |
  |  부울  |  bool   |  None  | NoneType |
  | 문자열 |   str   |  함수  | function |
  |  튜플  |  tuple  | 클래스 | 클래스명 |

  * 다수의 데이터를 저장할 수 있는 컨테이너

    |            | 기호 | 순서 |           중복           | 데이터변경 |                     비고                      |
    | :--------: | :--: | :--: | :----------------------: | :--------: | :-------------------------------------------: |
    |   tuple    | ( )  |  O   |            O             |     X      | 수의 나열은 tuple로 인식 / packing, unpacking |
    |    list    | [ ]  |  O   |            O             |     O      |                                               |
    | dictionary | { }  |  X   | 키의 중복X / 값의 중복 O |     O      |    키: 값의 구조로 저장 / 키는 불변 객체만    |
    |    set     | { }  |  X   |            X             |     O      |             불변 객체만 저장 가능             |

### 2. List 소개

* 배열(List)

  * 같은 타입 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

  * 파이썬의 리스트는 C나 Hava에서의 배열과 비슷한 자료구조

  * 변수를 사용하여 리스트로 바꾸어 사용함

    ```python
    num0 = 0
    num1 = 0
    num2 = 0
    num3 = 0
    
    =>
    num = []
    ```

  * **리스트를 사용하면 하나의 변수를 통해서 대량의 데이터를 효율적으로 처리할 수 있음!**

### 3. List 사용법

* 파이썬의 변수

  * 별도의 선언 방법이 없으며 변수에 처음 값을 할당할 때 생성

  * 값을 초기화하기 전에, 변수를 미리 만들어 두어야 할 경우

    * 공백 리스트 생성 

      ```python
      <방법1>
      num = []
      <방법2>
      arr = list()
      ```

  * 예) 배열과 리스트의 차이점

    ```python
    arr = [1, 3.14, "boy", [1, 2, "girl"]]
    ```

    |        |             배열              |             리스트             |
    | :----: | :---------------------------: | :----------------------------: |
    | 데이터 |   같은 타입의 데이터만 저장   | 다양한 데이터를 저장할 수 있음 |
    |  크기  | 처음 지정한 후 변경할 수 없음 |   가변적으로 변경할 수 있음    |

    * **배열보다 리스트가 사용하기 편리함**

  * 예) 2차원 리스트의 개념

    ```python
    arr = [[1, 2], [3, 4], [5, 6]]
    ```

* 시퀀스(Sequence) 자료형

  * 순서가 존재함으로, 인덱싱과 슬라이싱의 연산 모두 적용가능

  * 인덱싱(Indexing)

    * 시퀀스 자료형에서 하나의 요소를 인덱스 연산자를 통하여 참조하는 것

      ```python
      arr = [4, 5, 6, 7, 8, 9]
      arr[0] # 4
      arr[-1] # 9
      ```

  * 슬라이싱(Slicing)

    * 시퀀스 자료형의 원하는 범위를 선택하는 연산

      ```python
      arr = [4, 5, 6, 7, 8, 9]
      
      arr[1:3] # [5, 6]
      arr[:3]  # [4, 5, 6]
      arr[1:]  # [5, 6, 7, 8, 9]
      arr[:]   # [4, 5, 6, 7 ,8, 9]
      ```

* 함수와 연산

  |   함수   |        설명        |              예시               |      결과       |
  | :------: | :----------------: | :-----------------------------: | :-------------: |
  |  len()   |     원소 개수      |         len([2, 3, 4])          |        3        |
  |    +     |    시퀀스 연결     |       [1, 2, 3] + [4, 5]        | [1, 2, 3, 4, 5] |
  |    *     |        반복        |           [1, 2] * 2            |  [1, 2, 1, 2]   |
  |    in    |     소속하는지     |         2 in [1, 2, 3]          |      True       |
  |  not in  |  소속하지 않은지   |       2 not in [1, 2, 3]        |      False      |
  |  min()   |   원소 중 최소값   |         min([1, 2, 3])          |        1        |
  |  max()   |   원소 중 최대값   |         max([1, 2, 3])          |        3        |
  | sorted() | 정렬된 리스트 반환 | a = [3, 1, 2]; print(sorted(a)) |    [1, 2, 3]    |

  |   함수   |             설명              |                예시                |     결과     |
  | :------: | :---------------------------: | :--------------------------------: | :----------: |
  | append() |       리스트 끝에 추가        |      a = [1, 2]; a.append(3)       |  [1, 2, 3]   |
  | insert() |        해당위치에 삽입        |   a = [3, 4, 5]; a.insert(1, 9)    | [3, 9, 4, 5] |
  |  pop()   |     특정 index 항목 삭제      |      a = [3, 4, 5]; a.pop(1)       |    [3, 5]    |
  | remove() | 특정 값을 삭제(첫 번째요소만) |     a = [3, 4, 5]; a.remove(4)     |    [3, 5]    |
  | count()  |      일치하는 값의 개수       | a = [9, 4, 4, 9, 5, 9]; a.count(9) |      3       |

* 리스트 함축(List Comprehension)

  * 수학에서 집합을 정의하는 표현식과 유사함

  * 10보다 작은 짝수들의 집합을 원소로 하는 리스트

  * C/C++

    ```c
    int mylist[5] = {2, 3, 4, 5, 6};
    int newlist[5];
    for(int cnt=0, i = 0, i < 5, i++){
        if(mylist[i]%2==0){
            newlist[cnt++]=mylist[i];
        }
    }
    ```

  * 파이썬

    ```python
    mylist = [2, 3, 4, 5, 6]
    newlist = [i for i in mylist if i % 2 == 0]
    ```

## 3. Exhaustive Search

### 1. 완전 검색 소개

* 완전검색(Exhaustive Search)
  * 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
    1. Brute-force 혹은 Generate-and-Test 기법이라고도 불림
    2. 모든 경우의 수를 테스트한 후 최종 해법을 도출함
    3. 일반적으로 경우의 수가 상대적으로 작을 때 유용함
    4. 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
    5. 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직함

### 2. Baby-gin Game

* 예) Baby-gin 게임

  1. 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 떄, 3장의 카드가 연속적인 번호를 갖는 경우를 **run**이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 **triplete**이라고 함
  2. 6장의 카드가 run과 triplete로만 구성된 경우를 Baby-gin으로 부름

* 예) Baby-gin 게임의 입력

  1. 667767은 **두 개의 triplete**이므로 Baby-gin
     * **666, 777**
  2. 054060은 **한 개의 run**과 **한 개의 triplete**이므로 역시 Baby-gin
     * **456, 000**
  3. 101123은 한 개의 triplete가 존재하나, 023이 run이 아니므로 Baby-gin이 아님
     * **123을 run으로 사용하더라도 011이 run이나 triplete가 아님**

* 예) 6자리의 숫자를 입력 받아 Baby-gin 여부 찾기

  1. **고려할 수 있는 모든 경우의 수 생성하기**, 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)

     * 입력으로 {2, 3, 5, 7, 7, 7}을 받았을 경우, 아래와 같이 순열을 생성할 수 있음 : 완전 검색

  2. **해답 테스트하기**, 앞의 3자리와 뒤의 3자리를 잘라, run와 triplete 여부를 테스트하고 최종적으로 Baby-gin을 판단함

     235 777 / 235: 해당없음 777: triplete ==> **Baby-gin 아님!!**

* 순열(Permutation)

  * 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것

  1. 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현

     $nPr$

  2. nPr은 다음과 같은 식이 성립

     $nPr = n * (n-1) * (n-2) * ... * (n-r+1)$

  3. nPn = n!이라고 표기하며 Factorial이라 부름

* 예) {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수

  * **동일한 숫자가 포함되지 않았을 때, 각 자릿수 별로 loop을 이용**

    ```python
    for i1 in range(1, 4):
        for i2 in range(1, 4):
            if i2 != i1:
                for i3 in range(1, 4):
                    for i3 != i1 and i3 != i2:
                        print(i1, i2, i3)
    ```

## 4. Greedy Algorithm

### 1. 탐욕 알고리즘이란?

* 탐욕 알고리즘(Greedy Algorithm)

  * 최적 해를 구하는데 사용되는 근시안적인 방법

  1. 여러 경우 중 하나를 결정해야 할 때마다 **그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식**으로 진행하여 최종적인 해답에 도달함
  2. 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그것들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 **최적이라는 보장은 없음**
  3. 일반적으로, 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 **Greedy 접근**이 됨

* 탐욕 알고리즘의 수행 과정

  * 해 선택
    * 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 **부분 해 집합(Solution Set)에 추가**함
  * 실행 가능성 검사
    * 새로운 부분 해 집합이 실행 가능한지를 확인
    * 곧, **문제의 제약 조건을 위반하지 않는지를 검사**함
  * 해 검사
    * 새로운 부분 해 집합이 **문제의 해가 되는지를 확인**
    * 아직 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작**함

### 2. 탐욕 알고리즘의 예

* 예) 거스름돈 줄이기
  * 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?
    * 해 선택
      * 가장 좋은 해를 선택
      * 가장 **단위가 큰 동전을 하나 골라 거스름돈에 추가**함
    * 실행 가능성 검사
      * 거스름돈이 손님에게 내드려야 할 액수를 초과하는지를 확인
      * 초과한다면 **마지막에 추가한 동전을 거스름돈에서 빼고, 해 선택으로 돌아가서 현재보다 한 단계 작은 단위의 동전을 추가**함
    * 해 검사
      * 거스름돈이 손님에게 내드려야 하는 액수와 **일치하는지 확인**
      * 액수에 모자라면 다시 **해 선택으로 돌아가서 거스름돈에 추가할 동전을 고름**

### 3. baby-gin 다시 풀기

* 예) 완전 검색이 아닌 Baby-gin 방법으로 풀기

  1. 6개의 숫자는 6자리의 정수 값으로 입력됨
  2. COUNTS 리스트의 각 원소를 체크하여 run 과 triplete 및 Baby-gin 여부를 판단함
     * 탐욕 알고리즘을 적용함
     * COUNTS 리스트에서 run과 triplete 중에 가능한 것을 조사함
     * 조사에 사용한 데이터는 삭제함
     * 남은 데이터를 다시 run과 triplete 중에 가능한지를 조사함

* 예) 슈도코드로 표현한 구현

  ```python
  num = 456789 # Baby Gin 확인할 6자리 수
  c = [0] * 12 # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트
  
  for i in range(6):
      c[num % 10] += 1
      num //= 10
      
  i = 0
  tri = run = 0
  while i < 10:
      if c[i] >= 3: # triplete 조사 후 데이터 삭제
          c[i] -= 3
          tri += 1
          continue
      if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1: # run 조사 후 데이터 삭제
          c[i] -= 1
          c[i+1] -= 1
          c[i+2] -= 1
          run += 1
          continue
      i += 1
  if run + tri == 2:
      print("Baby Gin")
  else:
      print("Lose")
  ```

* 탐욕 알고리즘 접근의 경우, 해답을 찾아내지 못할 때

  * 입력 받은 숫자를 정렬한 후, 앞뒤 3자리씩 끊어서 run 및 triplete을 확하는 방법을 고려
  * 예) {6, 4, 4, 5, 4, 4}
    * 정렬하여 {4, 4, 4, 4, 5, 6}을 얻어내면 쉽게 Baby-gin을 확인할 수 있음
  * 예) {1, 2, 3, 1, 2, 3}
    * 정렬하여 {1, 1, 2, 2, 3, 3}로서, 오힐 Baby-gin 확인을 실패할 수 있음
  * => 유의점
    * **탐욕 알고리즘적인 접은은 해답을 찾아내지 못하는 경우도 있음**

## 5. Sort

### 1. 정렬 개요

* 정렬(Sort)이란?
  * 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순:ascending), 혹은 그 반대의 순서대로(내림차순: descending) 재배열하는 것
  * '키'란 자료를 정렬하는 기준이 되는 특정 값
    * 서류 번호대로 정렬하기
    * 카드 번호대로 정렬하기
* 대표정인 정렬 방식의 종류
  * **버블 정렬(Bubble Sort)**
  * **카운팅 정렬(Counting Sort)**
  * 선택 정렬(Selection Sort)
  * 퀵 정렬(Quick Sort)
  * 삽입 정렬(Insertion Sort)
  * 병합 정렬(Merge Sort)

### 2. 버블 정렬(Bubble Sort)

* 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

* 정렬과정

  1. 첫 번째 원소부터 인접한 원소끼리 계쏙 자리를 교환하면서 맨 마지막 자리까지 이동
  2. 한 단계가 끝나면 가장 큰 우너소 또는 가장 작ㅇ느 우너소가 마지막 자리로 정렬됨
  3. 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품모양 같아서 버블 정렬이라고 함

* **시간 복잡도 = O(n^2^)**

* 예) {55, 7, 78, 12, 42}를 버블 정렬하는 과정

  1. 첫 번째 패스
  2. 두 번째 패스
  3. 세 번째 패스
  4. 네 번째 패스

* 예) 리스트를 활용한 버블 정렬(슈도코드로 표현)

  ```python
  def BubbleSort(a): 정렬한 List
      for i in range(len(a)-1, 0, -1): # 범위의 끝 위치
          for j in range(0, i):
              if a[j] > a[j+1]:
                  a[j], a[j+1] = a[j+1], a[j]
  ```

### 3. 카운팅 정렬(Counting Sort)

* 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

* 정렬 과정

  * 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능, 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 딘덱스 되는 카운트들의 리스트를 사용하기 때문임
  * 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함

* **시간 복잡도 = O(n + k): n은 리스트의 개수, k는 정수의 최대값**

* 예) {0, 4, 1, 3, 1, 2, 4, 1}을 카운팅 정렬하는 과정

  1. Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 리스트 COUNTS에 저장
     * DATA : 0 4 1 3 1 2 4 1
     * COUNTS : 1 3 1 1 2     ## COUNTS[0] = 0의 발생 횟수 ... COUNTS[i] = i의 발생 횟수
  2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정
     * COUNTS: 1 4 5 6 8 ## 누계
  3. COUNTS[1]을 감소시키고 TEMP에 1을 삽입
     * J = 7
     * COUNTS[1]이 4이므로 TEMP의 4번째 자리에 1을 삽입
     * TEMP : - - - 1 - - - -
     * COUNTS : 1 3 5 6 8
  4. COUNTS[4]를 감소시키고 TEMP에 4를 삽입
     * J = 6
     * COUNTS[4]가 8이므로 TEMP의 8번째 자리에 4를 삽입
     * TEMP : - - - 1 - - - 4
     * COUNTS : 1 3 5 6 7
  5. COUNTS[2]를 감소시키고 TEMP에 2를 삽입
     * J = 5
     * COUNTS[2]가 5이므로 TEMP의 5번째 자리에 2를 삽입
     * TEMP : - - - 1 2 - - 4
     * COUNTS : 1 3 4 6 7
  6. COUNTS[1]을 감소시키고 TEMP에 1을 삽입
     * J = 4
     * COUNTS[1]이 3이므로 TEMP의 3번째 자리에 1을 삽입
     * TEMP : - - 1 1 2 - - 4
     * COUNTS: 1 2 4 6 7
  7. COUNTS[3]을 감소시키고 TEMP에 3을 삽입
     * J = 3
     * COUNTS[3]이 6 이므로 TEMP의 6번째 자리에 3을 삽입
     * TEMP : - - 1 1 2 3 - 4
     * COUNTS : 1 2 4 5 7
  8. COUNTS[1]을 감소시키고 TEMP에 1을 삽입
     * J = 2
     * COUNTS[1]이 2이므로 TEMP의 2번째 자리에 1을 삽입
     * TEMP : - 1 1 1 2 3 - 4
     * COUNTS : 1 1 4 5 7
  9. COUNTS[4]를 감소시키고 TEMP에 4를 삽입
     * J = 1
     * COUNTS[4]가 7이므로 TEMP의 7번째 자리에 4를 삽입
     * TEMP : - 1 1 1 2 3 4 4
     * COUNTS : 1 1 4 5 6
  10. COUNTS[0]를 감소시키고 TEMP에 0을 삽입
      * J = 0
      * COUNTS[0]가 1이므로 TEMP의 첫 번째 자리에 0을 삽입
      * TEMP : 0 1 1 1 2 3 4 4
      * COUNTS : 0 3 1 1 2
  11. TEMP 업데이트 완료하고 정렬 작업을 종료

  ```python
  def CountingSort(A, B, k):
      # A[1 .. n] -- 입력 리스트 사용된 숫자(1 ~ k)
      # B[1 .. n] -- 정렬된 리스트
      # C[1 .. k] -- 카운트 리스트
      
      C = [0] * k
      
      for i in range(0, len(B)):
          C[A[i]] += 1
          
      for i in range(1, len(C)):
          C[i] += C[i-1]
          
      for i in range(len(B)-1, -1, -1):
          B[C[A[i]]-1] = A[i]
          C[A[i]] -= 1
          
  a = [0, 4, 1, 3, 1, 2, 4, 1]
  b = [0] * len(a)
  CountingSort(a, b, 5)
  print(b)
  ```

* 버블 정렬과 카운팅 정렬

|  알고리즘   | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 |                       비고                       |
| :---------: | :-----------: | :-----------: | :-----------: | :----------------------------------------------: |
|  버블 정렬  |    O(n^2)     |    O(n^2)     |  비교와 교환  |                코딩이 가장 손쉬움                |
| 카운팅 정렬 |    O(n+k)     |    O(n+k)     |  비교환 방식  |            n이 비교적 작을 때만 가능             |
|  선택 정렬  |    O(n^2)     |    O(n^2)     |  비교와 교환  |      교환의 회수가 버블, 삽입정렬보다 작음       |
|   퀵 정렬   |  O(n log n)   |    O(n^2)     |   분할 정복   | 최악의 경우 O(n^2)이지만, 평균적으로는 가장 빠름 |
|  삽입 정렬  |    O(n^2)     |    O(n^2)     |  비교와 교환  |            n의 개수가 작을 때 효과적             |
|  병합 정렬  |  O(n log n)   |  O(n log n)   |   분할 정복   |      연결 리스트의 경우 가장 효율적인 방식       |



