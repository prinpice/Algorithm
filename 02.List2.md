#  02. List2

##  1. 2차원 List

#### 학습목표

1. 2차원 리스트를 선언하고 활용할 수 있다.
2. **2차원 리스트의 순회 방법**을 이해하고 활용할 수 있다.
3. **부분집합을 구하는 알고리즘**을 이해하고 활용할 수 있다.
4. 검색의 개념을 설명할 수 있다.
5. **순차 검색**에 대해 이해하고 활용할 수 있다.
6. **이진 검색**에 대해 이해하고 활용할 수 있다.
7. 인덱스 개념을 이해하고 활용할 수 있다.
8. **선택정렬(셀렉션 알고리즘)**에 대하여 설명할 수 있다.
9. **선택 정렬**을 이해하고 활용할 수 있다.



### 1-1. 2차원 List 구조

- 1차원 리스트를 묶어놓은 리스트
- 2차원 이상의 다차원 리스트는 자원에따라 인덱스 선언
- 2차원 리스트 선언 : 세로길이(콜롬 수), 가로길이(row수)가 필요
- 파이썬에서는 데이터 초기화를 통해 변수선언과 초기화 가능
- 2행 4열의 2차원 리스트 예 ) `arr = [[1,2,3,4],[4,5,6,7]]`

### 1-2. List 초기화

```python
#초기화1
arr = [0,0,0,0,0]
#초기화2 (=초기화1)
arr = [0]*5
#초기화3 [2,4,6,8]
arr = [i for in range(2,9) if i%2==0]
#초기화4 [[1,2,3],[1,2,3],[1,2,3]]
arr = [[1,2,3] for in range(3)]
#초기화5 [[0,0], [0,1], [1,0], [1,1], [2,0], [2,1]]
arr = [[i,j]for i in range(3) for j in range(2)]
```

###  1-3. 2차원 List 입력 받기

- 여러가지가 있다. 

###  1-4. 2차원 List에서 데이터 위치 찾기

###  1-5. 2차원 List의 순회

####  1) 행 우선 순회

- N * M 크기의 리스트 순회

  ``` python
  for i in range(N):
      for j in range(M):
          print(arr[i][j])
  ```

####  2)열 우선 순회

- N * M 크기의 리스트 순회 : 행우선 순회에서 열,행의 순회순서 바꿈

  ``` python
  for j in range(N):
      for i in range(M):
          print(arr[i][j])
  ```

####  3)지그재그 순회

- 리스트의 행을 좌우로 순회 : 순회방향에 따라 인덱스 값이 커지고 작아지는게 반복

  ``` python
  for i in range(N):
      for j in range(M):
          print(arr[i][j+(M-1-2*j)*(i%2)])
  ```

###  1-6. 델타를 이용한 2차 List 탐색

- 2차 리스트의 한 좌표에서 네방향의 인접 리스트 요소 탐색

- 한 좌표에서 네방향의 좌표와 x,y의 차이를 저장한 리스트로 구현

- 델타 값을 이용하여 특정 원소의 상하좌우에 위치한 원소에 접근가능

  ``` python
  arr = [[1,2,3,4],[5,6,7,8],[9,9,0,0]]
  N = 4
  M = 3
  
  dx = [0,0,-1,1]
  dy = [-1,1,0,0]
  
  for x in range(N):
      for y in range(M):
          for i in range(4):
              testX = x + dx[i]
              testY = y + dy[i]
              print(f'기준좌표:{arr[x][y]}, 방향:{i}, {arr[testX][testY]}')
  # 위 코드의 문제 IndexError: list index out of range
  ```

###  1-7. 전치행렬

- 행, 열의 값이 반대인 행렬

- 전치행렬을 만드는 방법 : 순회하면서 행, 열을 스왑한다. 

- 모든 좌표에 대해 바꾸면 본래 모습으로 되돌아가므로 주의 : 조건을 걸어야 한다. 

  ``` python
  for x in range(N):
      for y in range(M):
          if i<j:
              arr[i][j],arr[j][i] = arr[j][i],arr[i][j]
  ```

####  zip 함수 

- 파이썬 내장함수 

- 동일한 개수로 이루어진 자료형들을 묶어주는 함수

- 묶은 결과는 리스트나 딕셔너리 객체로 만들수 있다.

- 객채의 갯수가 동일하지 않은 자료형을 묶으면 갯수가 적은 리스트를 기준으로 묶는다.

- 리스트를 행 별로 쪼개서 사용할 수 있다.  `*리스트명` 은  리스트를 행별로 분리하는 역할

- 그러므로, zip(*2차배열) 을 통해 전치 행렬을 생성할 수 있다.   

  ```python
  A = ['a','b','c']
  I = [1,2,3]
  zipList = list(zip(A,I))
  zipDict = dict(zip(A,I))
  print(zipList)
  print(zipDict)
  # >>> [('a', 1), ('b', 2), ('c', 3)]
  # >>> {'a': 1, 'b': 2, 'c': 3}
  
  arr = [[1,2,3],[4,5,6],[7,8,9]]
  zipList2 = list(zip(*arr))
  print(zipList2)
  # >>> [(1, 4, 7), (2, 5, 8), (3, 6, 9)]
  ```

##  2. 부분 집합

###  2-1. 부분 집합 문제 

#### 문제 1 : 부분집합의 합

정수로 이루어진 집합의 부분집합 중 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지 알아내는 문제

- 집합 예) `{-7, -3, -2, 5, 8}`  조건에 맞는 부분집합 예) `{-3, -2, 5}`
- 문제해결 순서
  - 완전검색하여 모든 부분집합 생성 
  - 각 부분집합의 합 계산

#### 문제 2 : 부분집합의 수

부분집합의 총 갯수가 몇개일까 

- 집합의 뭔소가 n개일 때 공집합을 포함한 부분집한의 수는 2**n개 
- 각 원소를 부분집합에 포함시키거나 포함시키지 않는 (두가지 경우*모든 원소)에 적용한 경우의 수와 같음
  -  `{1,2,3,4}` => `2*2*2*2 = 16`  

### 2-2. 부분집합 문제 알고리즘 1 

- Loop를 이용하여 확인하고, 부분집합을 생성하는 방법

- 활용: 생성된 부분집합으로 이진수를 헤아릴 수 있다.   

  ``` python
  bit = [0]*4			# bit[i, j, k, l]
  for i in range(2):
      bit[0] = i
      for j in range(2):
          bit[1] = j
          for k in range(2):
              bit[2] = k
              for l in range(2):
                  bit[3] = l
                  print(bit)
  '''
  [0, 0, 0, 0] = 1
  [0, 0, 0, 1] = 2 
  [0, 0, 1, 0]  ... 
  [0, 0, 1, 1]
  [0, 1, 0, 0]
  [0, 1, 0, 1]
  [0, 1, 1, 0]
  [0, 1, 1, 1]
  [1, 0, 0, 0]
  [1, 0, 0, 1]
  [1, 0, 1, 0]
  [1, 0, 1, 1]
  [1, 1, 0, 0]
  [1, 1, 0, 1]
  [1, 1, 1, 0]  ... 
  [1, 1, 1, 1] = 16
  '''
  ```


### 2-3.  부분집합 문제 알고리즘 2

- 비트 연산자 : 이진수에 대해 연산을 수행

- 비트 연산자의 종류 

  - 몰라도 될것같다

  - 가정) a = 11 , b = 13 

    | Oper | Description      | Example      | Ex) bit   |
    | ---- | ---------------- | ------------ | --------- |
    | &    | AND : 둘다 참일때만 만족  | bin(a & b)  | a = 0b1011<br>b = 0b1101<br>출= 0b1001 |
    | \|   | OR : 둘 중 하나만 참이여도 만족| bin(a \| b)| a = 0b1011<br>b = 0b1101<br> 출= 0b1111 |
    | ^    | XOR : 둘 중 하나만 참일 때 만족  | bin(a ^ b) | a = 0b1011<br>b = 0b1101<br> 출=0b110 |
    | ~    | 보수 연산     | [링크참조](https://master-hun.tistory.com/48) | 몰라도될것같다  |
    | <<   | 왼쪽 시프트 :<br>변수값을 좌로 지정된 비트 수 만큼 이동  | bin(a<<2)<br>bin(b<<1)  | a = 0b1011<br>b = 0b1101<br>출= 0b101100<br>출= 0b11010 |
    | \>>  | 오른쪽 시프트:<br>변수값을 우로 지정된 비트 수 만큼 이동 | bin(a>>2)<br/>bin(b>>1) | 출= 0b10<br>출= 0b110                                   |

- `1<< n:2**n`  : 원소가 n개일 경우 모든 부분집합의 수를 리턴  

- `i&(1<<j):1`  : i 에서 j번째 비트가 1인지 아닌지 리턴 

- 효율적으로 부분집합을 생성할 수 있다.  아래 코드를 출력하면 모든 부분집합을 출력. 

  ```python
  arr = [3,6,7,1,5,4]
  N= len(arr)
  
  for i in range(1 << N):  # 부분집합의 갯수만큼 순회 (0,64)
      # print('i:', i)
      for j in range(N):   # 원소 수만큼 비트 비교, 원소의 포함 여부 판단 가능 (0,6)
          #print('j:', j)
          if i & (1<<j):   # i의 j번째 비트가 1이면 j번쨰 원소 출력
              print(arr[j], end=', ')  # 3,6,7,1,5,4 
              #print(1 << j)  # 1,2,4,8,16,32 
      print()
  ```

## 3. 검색

#### 검색 개요

- 저장된 자료 중 원하는항목(목적하는 탐색키(자료를 구별하여 인식할수 있는키)를 가진항목)을 찾는 작업 
- 종류 : 순차 검색, 이진검색, 인덱싱

###  3-1. 순차검색 (Sequential Search)

- 일렬로 되어있는 자료를 순서대로 검색, 간단하고 직관적

- 리스트 및 연결리스트 등 순차적으로 구현된 자료구조에서 유용

- 구현이 쉽지만 검색대상이 많은경우 수행시간 급증, 비효율적

- 정렬 여부에 따라 검색 

  - **정렬되지 않은 자료**: 

    1. 첫번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하여 찾음
    2. 찾으면 그 원소의 인덱스 반환
    3. 끝까지 검색 대상을 찾지 목하면 검색 실패

    - 평균 비교횟수 : (n+1)/2  
    - 시간복잡도 : O(n) 

    ``` python
    def SequentialSearch (arr,N,key):
        i = 0
        while i < N and arr[i] != key:
            i += 1
       if i < N : return i   # 끝까지 돌기 전에 arr[i] == key 찾으면 i 반환
       else : return -1 	 # 그렇지 않으면 False
    ```

  - **정렬된 자료:**

    1. 자료가 오름차순으로 정렬된 상태라고 가정
    2. 순차적으로 검색하면서 키 값 비교
    3. 원소 키 값이 검색 대상의 키 값보다 크면 원소가 없다는 의미 : 검색 종료

    - 평균 비교횟수 : 정렬되지 않은 자료의 반
    - 시간복잡도 : O(n) 

    ``` python
    def SequentialSearch2 (arr,N,key):
        i = 0
        while i < N and arr[i] < key:
            i += 1
       if i < N and arr[i] == key:
        : return i			 # 끝까지 돌기 전에 arr[i] == key 찾으면 i 반환
       else : return -1 	 # 그렇지 않으면 False
    ```


###  3-2.  이진검색 (Binary Search)

- 효율적

- 자료의 가운데 항목의 키값과 비교, 다음 검색의 위치를 결정하고 검색 계속 이행

  - 목적 키를 찾을 때 까지 이진 검색 반복 수행 : 검색 범위를 반으로 줄여가면서 빠르게 검색

- 자료가 정렬된 상태여야 가능

- 시간복잡도 : O(logN)

- 검색과정:

  1. 자료 중앙의 원소 선택 

  2. 중앙 원소 값(a)과 목표 값(key) 비교

  3. - a < key 라면 : 자료 오른쪽 반에 대해 이진 검색

     - key < a 라면 :  자료 왼쪽 반에 대해 이진 검색

  4.  찾고자 하는 값을 찾을 때 까지 반복  

  - 검색 범위의 시작, 종료점을 이용하여 반복수행 
  - 자료 삽입 및 삭제시 리스트의 상태를 항상 정렬 상태로 유지하는 추가작업이 필요

  ```python
  def binarySearh(a,key):
      start = 0
      end = len(a)-1  
      while start <= end:
          middle = start+(end-start)//2 
          if key == a[middle]:  #검색성공
              return True
          elif key < a[middle]:
              end = middle-1
          else:
              start = middle+1
      return False #검색실패
  ```

####  재귀함수를 이용한 이진검색

``` python
def binarySearh1(a,low,high,key):
    if low > high : # 검색 실패 
        return False 
    else: 
        middle = (low+high)//2 
        if key == a[middle]:  #검색성공
            return True
        elif key < a[middle]:
            return binarySearch2(a,low,middle-1,key)
        else:
            return binarySearch2(a,middle+1,high,key)
```



### 3-3. 인덱싱 (Indexing)

- DB에서 유래, 테이블에 대한 동작속도를 높임
- DB분야 외에서는 룩 업 테이블 등의 용어로 사용하기도 함
- 인덱스 저장에 필요한 디스크 공간은 테이블 저장에 필요한 공간보다 작음
  - 인덱스는 키필드만 가지고, 세부 항목은 갖고 있지 않기 때문
- 리스트를 사용한 인덱스
  - 대량의 데이터를 매번 정렬하면 속도 저하의 문제 : 해결을 위해 리스트 인덱스 사용 

## 4. 정렬

###  4-1. 셀렉션 알고리즘

- 저장되어있는 자료로부터 k번째로 크거나 작은, 최소값, 최대값, 중간값 등의 원소 찾기

- 과정

  1. 정렬 알고리즘을 이용하여 정렬 

  2. 원하는 순서에 있는 원소 가져오기

- 예시 ) k번째로 작은 원소 찾기 알고리즘

  - 1번~k번째로 작은 원소들을 찾아 리스트 앞쪽으로 이동시키고, 리스트의 k번째 반환

  - k가 비교적 작을 때 유용

  - 수행시간: O(kn)

    ``` python
    def select(list,k):
        for i in range(0,k):
            minIndex = i
            for j in range(i+1,len(list)):
                if list[minIndex] > list[j]:
                    miniIndex = j 
            list[i], list[miniIndex], list[i]
        return list[k-1]
    ```


### 4-2. 선택 정렬

- 생활 예시) 포켓볼 순서대로 정렬하기

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 

- 셀렉션 알고리즘을 전체 자료에 적용

- 과정

  1. 주어진 리스트 중 최소값 찾기
  2. 그 값을 리스트 맨 앞에 위치한 값과 교환
  3. 맨처음 위치를 제외한 나머지 리스트를 대항으로 과정 반복

- 시간복잡도: O(n**2)

  ``` python
  def selectionSort(a):
  	for i in range(0,len(a)-1):
          min = i
          for j in range(i+1,len(a)):
              if a[min] > a[j]:
                  min =j
          a[i],a[min] = a[min],a[i]
  ```


## 

#### 정렬 알고리즘의 특성 비교 

| 알고리즘    | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고                           |
| ----------- | ------------- | ------------- | ------------- | ------------------------------ |
| 버블 정렬   | O(n**2)       | O(n**2)       | 비교, 교환    | 코딩이 가장 손쉬움             |
| 카운팅 정렬 | O(n+K)        | O(n+k)        | 비교환        | n이 비교적 작을때만 가능       |
| 선택 정렬   | O(n**2)       | O(n**2)       | 비교, 교환    | 교환의 수가 버블,삽입보다 작음 |
| 퀵 정렬     | O(n log n)    | O(n**2)       | 분할 정복     | 평균적으로는 가장빠름          |
| 삽입 정렬   | O(n**2)       | O(n**2)       | 비교, 교환    | n의 개수가 작을떄 효과적       |
| 병합 정렬   | O(n log n)    | O(n log n)    | 분할 정복     | 연결 List의 경우 가장 효율적   |

